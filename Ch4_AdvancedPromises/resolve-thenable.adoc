[[resolve-thenable]]
== Promise.resolve和Thenable

在 <<ch2-promise-resolve,第二章的Promise.resolve>> 中我们已经说过， `Promise.resolve` 的最大特征之一就是可以转换将thenable的对象转换为promise对象。

在本小节里，我们将学习一下利用将thenable对象转换为promise对象这个功能都能具体做些什么实际的事情。

=== 将Web Notifications转换为thenable对象

这里我们以桌面通知 API https://developer.mozilla.org/ja/docs/Web/API/notification[Web Notifications] 为例进行说明。

关于Web Notifications API的详细信息可以参考下面的网址。

* https://developer.mozilla.org/zh-TW/docs/WebAPI/Using_Web_Notifications[使用 Web Notifications - WebAPI | MDN]
* http://caniuse.com/notifications[Can I use Web Notifications]

简单来说，Web Notifications API就是能像以下代码那样通过 `new Notification` 来显示通知消息。

[source,javascript]
new Notification("Hi!");

当然，为了显示通知消息，我们需要在运行 `new Notification` 之前，先获得用户的许可。

.确认是否允许Notification的对话框
image::img/notification-dialog.png[确认是否允许Notification的对话框]

用户在这个是否允许Notification的对话框选择后的结果，会通过 `Notification.permission` 传给我们的程序，它的值可能是允许("granted")或拒绝("denied")这二者之一。

[NOTE]
是否允许Notification对话框中的可选项，在Firefox中除了允许、拒绝之外，还增加了 __永久有效__ 和 __绘画范围内有效__ 两种额外选项，当然 `Notification.permission` 的值都是一样的。

在程序中可以通过 `Notification.requestPermission()` 来弹出是否允许Notification对话框，
用户选择的结果会通过 `status` 参数传给回调函数。

从这个毁掉函数我们也可以看出来，用户选择允许还是拒绝通知是异步进行的。

[role="executable"]
[source,javascript]
----
Notification.requestPermission(function (status) {
    // status的值为 "granted" 或 "denied"
    console.log(status);
});
----

到用户收到并显示通知为止，整体的处理流程如下所示。

* 显示是否允许通知的对话框，并异步处理用户选择结果
* 如果用户允许的话，则通过 `new Notification` 显示通知消息。这又分两种情况
** 用户之前已经允许过
** 当场弹出是否允许桌面通知对话框
* 当用户不允许的时候，不执行任何操作


虽然上面说到了几种情景，但是最终结果就是用户允许或者拒绝，可以总结为如下两种模式。

允许时("granted"):::
    使用 `new Notification` 创建通知消息
拒绝时("denied"):::
    没有任何操作

这两种模式是不是觉得有在哪里看过的感觉？
呵呵，用户的选择结果，正和在Promise中promise对象变为 Fulfilled 或 Rejected 状态非常类似。

resolve(成功)时 == 用户允许("granted")::
    调用 `onFulfilled` 方法
reject(失败)时 == 用户拒绝("denied")::
    调用 `onRejected` 函数

是不是我们可以用Promise的方式去编写桌面通知的代码呢？我们先从回调函数风格的代码入手看看到底怎么去做。

=== Web Notification 包装函数（wrapper）

首先，我们以回到函数风格的代码对上面的Web Notification API包装函数进行重写，新代码如下所示。

[role="executable"]
[source,javascript]
[[notification-callback.js]]
.notification-callback.js
----
include::embed/embed-notification-callback.js[]
// 运行实例
// 第二个参数是传给 `Notification` 的option对象
notifyMessage("Hi!", {}, function (error, notification) {
    if(error){
        return console.error(error);
    }
    console.log(notification);// 通知对象
});
----

在回调风格的代码里，当用户拒绝接收通知的时候， `error` 会被设置值，而如果用户同意接收通知的时候，则会显示通知消息并且 `notification` 会被设置值。

[source,javascript]
.回调函数接收error和notification两个参数
----
function callback(error, notification){

}
----

下面，我想再将这个回调函数风格的代码使用Promise进行改写。

=== Web Notification as Promise

基于上述回调风格的 `notifyMessage` 函数，我们再来创建一个返回promise对象的 `notifyMessageAsPromise` 方法。

[role="executable"]
[source,javascript]
[[notification-as-promise.js]]
.notification-as-promise.js
----
include::embed/embed-notification-as-promise.js[]
// 运行示例
notifyMessageAsPromise("Hi!").then(function (notification) {
    console.log(notification);// 通知对象
}).catch(function(error){
    console.error(error);
});
----

在用户允许接收通知的时候，运行上面的代码，会显示 `"Hi!"` 消息。

当用户接收通知消息的时候， `.then` 函数会被调用，当用户拒绝接收消息的时候， `.catch` 方法会被调用。

[NOTE]
====
由于浏览器是以网站为单位保存Web Notifications API的许可状态的，所以实际上有下面四种模式存在。

已经获得用户许可::
    `.then` 方法被调用
弹出询问对话框并获得许可::
    `.then` 方法被调用
已经是被用户拒绝的状态::
    `.catch` 方法被调用
弹出询问对话框并被用户拒绝::
    `.catch` 方法被调用

也就是说，如果使用原生的Web Notifications API的话，那么需要在程序中对上述四种情况都进行处理，我们可以像下面的包装函数那样，将上述四种情况简化为两种以方便处理。
====

上面的 <<notification-as-promise.js>> 虽然看上去很方便，但是实际上使用的时候，很可能出现 **在不支持Promise的环境下不能使用** 的问题。

<<notification-as-promise.js>>のようなPromiseスタイルで使えるライブラリを作る場合、
ライブラリ作成者には以下の選択肢があると思います。

[[promise-library-choice]]
Promiseが使える環境を前提とする::
* 利用者に `Promise` があることを保証してもらう
* Promiseをサポートしてない環境では動かないことにする
ライブラリ自体に `Promise` の実装を入れてしまう::
* ライブラリ自体にPromiseの実装を取り込む
* 例) https://github.com/mozilla/localForage[localForage]
コールバックでも `Promise` でも使えるようにする::
* 利用者がどちらを使うかを選択出来るようにする
* Thenableを返せるようにする

<<notification-as-promise.js>>は `Promise` があることを前提としたような書き方です。

本題に戻り<<Thenable,Thenable>>はここでいう**コールバックでも `Promise` でも使えるようにする**という事を
実現するのに役立つ概念です。

=== Web Notifications As Thenable

<<Thenable,thenable>>というのは `.then` というメソッドを持ってるオブジェクトのことを言いましたね。
次は<<notification-callback.js>>に `thenable` を返すメソッドを追加してみましょう。

[role="executable"]
[source,javascript]
[[notification-thenable.js]]
.notification-thenable.js
----
include::embed/embed-notification-thenable.js[]
// 运行示例
Promise.resolve(notifyMessageAsThenable("message")).then(function (notification) {
    console.log(notification);// 通知对象
}).catch(function(error){
    console.error(error);
});
----

<<notification-thenable.js>> には `notifyMessageAsThenable` というそのままのメソッドを追加してみました。
返すオブジェクトには `then` というメソッドがあります。

`then` メソッドの仮引数には `new Promise(function (resolve, reject){})` と同じように、
解決した時に呼ぶ `resolve` と、棄却した時に呼ぶ `reject` が渡ります。

`then` メソッドがやっている中身は<<notification-as-promise.js>>の `notifyMessageAsPromise` と同じですね。

この `thenable` を `Promise.resolve(thenable)` を使いpromiseオブジェクトにしてから、
Promiseとして利用していることが分かりますね。

[source,javascript]
----
Promise.resolve(notifyMessageAsThenable("message")).then(function (notification) {
    console.log(notification);// 通知对象
}).catch(function(error){
    console.error(error);
});
----

Thenableを使った<<notification-thenable.js>>とPromiseに依存した<<notification-as-promise.js>>は、
非常に似た使い方ができることがわかります。

<<notification-thenable.js>>には<<notification-as-promise.js>>と比べた時に、次のような違いがあります。

* ライブラリ側に `Promise` 実装そのものはでてこない
** 利用者が `Promise.resolve(thenable)` を使い `Promise` の実装を与える
* Promiseとして使う時に `Promise.resolve(thenable)` と一枚挟む必要がある

<<Thenable,Thenable>>オブジェクトを利用することで、
既存のコールバックスタイルとPromiseスタイルの中間的な実装をすることができました。

=== 总结

このセクションではThenableとは何かやThenableを `Promise.resolve(thenable)` を使って、
promiseオブジェクトとして利用する方法について学びました。

Callback -- Thenable -- Promise

Thenableスタイルは、コールバックスタイルとPromiseスタイルの中間的な表現で、
ライブラリが公開するAPIとしては中途半端なためあまり見かけることがないと思います。

Thenable自体は `Promise` という機能に依存してはいませんが、Promise以外からの利用方法は特にないため、
間接的にはPromiseに依存しています。

また、使うためには利用者が `Promise.resolve(thenable)` について理解している必要があるため、
ライブラリの公開APIとしては難しい部分があります。
Thenable自体は公開APIより、内部的に使われてるケースが多いでしょう。

[NOTE]
====
非同期処理を行うライブラリを書く際には、まずはコールバックスタイルの関数を書いて公開APIとすることをオススメします。

Node.jsのCore moduleがこの方法をとっているように、ライブラリが提供するのは基本となるコールバックスタイル関数としたほうが、
利用者がPromiseやGenerator等の好きな方法で実装ができるためです。

最初からPromiseで利用することを目的としたライブラリや、その機能がPromiseに依存している場合は、
promiseオブジェクトを返す関数を公開APIとしても問題ないと思います。
====

==== 什么时候该使用Thenable？

那么，又是在什么情况下应该使用Thenable呢？

恐らく、一番多く使われている所は<<promise-library,Promiseのライブラリ>>間での相互変換でしょう。

例えば、 QライブラリのPromiseのインスタンスであるQ promiseオブジェクトは、
<<es6-promises,ES6 Promises>>のpromiseオブジェクトが持っていないメソッドを持っています。
Q promiseオブジェクトには `promise.finally(callback)` や `promise.nodeify(callback)` などのメソッドが用意されてます。

ES6 PromisesのpromiseオブジェクトをQ promiseオブジェクトに変換するときに使われるのが、
まさにこのThenableです。

[source,javascript]
.使用thenable将promise对象转换为Q promise对象
----
var Q = require("Q");
// 这是一个ES6的promise对象
var promise = new Promise(function(resolve){
    resolve(1);
});
// 变换为Q promise对象
Q(promise).then(function(value){
    console.log(value);
}).finally(function(){ // <1>
    console.log("finally");
});
----
<1> 因为是Q promise对象所以可以使用 `finally` 方法

最初に作成したpromiseオブジェクトは `then` というメソッドを持っているので、もちろんThenableです。
`Q(thenable)` とすることでThenableなオブジェクトをQ promiseオブジェクトへと変換することが出来ます。

これは、`Promise.resolve(thenable)` と同じ仕組みといえるので、もちろん逆も可能です。

このように、Promiseライブラリはそれぞれ独自に拡張したpromiseオブジェクトを持っていますが、
Thenableという共通の概念を使うことでライブラリ間(もちろんネイティブPromiseも含めて)で相互にpromiseオブジェクトを変換することが出来ます。

このようにThenableが使われる所の多くはライブラリ内部の実装であるため、あまり目にする機会はないかもしれません。
しかしこのThenableはPromiseでも大事な概念であるため知っておくとよいでしょう。