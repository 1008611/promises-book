[[race-delay-timeout]]
== 使用Promise.race和delay取消XHR请求

在本小节中，作为在第<<ch2-promise-race,2章>>所学的 <<Promise.race,`Promise.race`>> 的用例，我们来看一下如何使用Promise.race来实现超时机制。

当然XHR有一个 https://developer.mozilla.org/ja/docs/XMLHttpRequest/Synchronous_and_Asynchronous_Requests[timeout] 属性，使用该属性也可以简单实现超时功能，但是为了能支持多个XHR同时超时或者其他功能，我们采用了容易理解的异步方式在XHR中通过超时来实现取消正在进行中的操作。

=== 让Promise等待指定时间

首先我们来看一下如何在Promise中实现超时。

所谓超时就是要在经过一定时间后进行某些操作，使用 `setTimeout` 的话很好立即。

首先我们来串讲一个单纯的在Promise中调用  `setTimeout` 的函数。

[source,javascript]
[[delayPromise.js]]
.delayPromise.js
----
include::embed/embed-delayPromise.js[]
----

`delayPromise(ms)` 返回一个在经过了参数指定的毫秒数后进行onFulfilled操作的promise对象，这和直接使用 `setTimeout` 函数比较起来只是编码上略有不同，如下所示。

[source,javascript]
----
setTimeout(function () {
    alert("已经过了100ms！");
}, 100);
// == 几乎同样的操作
delayPromise(100).then(function () {
    alert("已经过了100ms！");
});
----

在这里 **promise对象** 这个概念非常重要，请切记。

=== Promise.race中的超时

让我们回顾一下静态方法 `Promise.race` ，它的作用是在任何一个promise对象进入到确定（解决）状态后就继续进行后续处理，如下面的例子所示。

[source,javascript]
----
include::../Ch2_HowToWrite/embed/embed-promise-race-other.js[]
----

我们可以将刚才的 <<delayPromise.js,delayPromise>> 和其它promise对象一起放到 
`Promise.race` 中来是实现简单的超时机制。

[source,javascript]
[[simple-timeout-promise.js]]
.simple-timeout-promise.js
----
include::embed/embed-simple-timeout-promise.js[]
----

函数 `timeoutPromise(比较对象promise, ms)` 接收两个参数，第一个是需要使用超时机制的promise对象，第二个参数是超时时间，它返回一个由 `Promise.race` 创建的相互竞争的promise对象。

之后我们就可以使用 `timeoutPromise` 编写下面这样的具有超时机制的代码了。

[role="executable"]
[source,javascript]
----
include::embed/embed-simple-timeout-promise.js[]
// 运行示例
var taskPromise = new Promise(function(resolve){
    // 随便一些什么处理
    var delay = Math.random() * 2000;
    setTimeout(function(){
        resolve(delay + "ms");
    }, delay);
});
timeoutPromise(taskPromise, 1000).then(function(value){
    console.log("taskPromise在规定时间内结束 : " + value);
}).catch(function(error){
    console.log("发生超时", error);
});
----

虽然在发生超时的时候跑出了异常，但是这样的话我们就不能区分这个异常到底是__普通的错误__还是__超时错误__了。

为了能区分这个 `Error` 对象的类型，我们再来定义一个`Error` 对象的子类 `TimeoutError`。

=== 定制Error对象

`Error` 对象是ECMAScript的内建（build in）对象。

但是由于stack trace等原因我们不能完美的创建一个继承自 `Error` 的类，不过在这里我们的目的只是为了和Error有所区别，我们将创建一个 `TimeoutError` 类来实现我们的目的。

[NOTE]
====
在ECMAScript6中可以使用 `class` 语法来正确的实现类之间的继承关系。

[source,javascript]
----
class MyError extends Error{
    // 继承了Error类的对象
}
----
====


我们让我们的 `TimeoutError` 能支持类似 `error instanceof TimeoutError` 的使用方法，我们还需要进行如下工作。

[source,javascript]
[[TimeoutError.js]]
.TimeoutError.js
----
include::embed/embed-TimeoutError.js[]
----

我们定义了 `TimeoutError` 类和构造函数，这个类继承了Error的prototype。

使用方法的话则和普通的 `Error` 对象一样，使用 `throw` 语句即可，如下所示。

[source,javascript]
----
var promise = new Promise(function(){
    throw TimeoutError("timeout");
});

promise.catch(function(error){
    console.log(error instanceof TimeoutError);// true
});

----

只有这个 `TimeoutError` 对象，我们就能很容易区分捕获的到底是因为超时而导致的错误，还是其他原因导致的Error对象了。

[NOTE]
====

本章里介绍的继承JavaScript内建对象的方法可以参考 http://speakingjs.com/es5/ch28.html[Chapter 28. Subclassing Built-ins] ，那里有详细的说明。此外 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Error[Error - JavaScript | MDN] 也针对Error对象进行了详细说明。
====

=== 通过超时取消XHR操作

ここまでくれば、どのようにPromiseを使ったXHRのキャンセルを実装するか見えてくるかもしれません。

XHRのキャンセル自体は `XMLHttpRequest` オブジェクトの `abort()` メソッドを呼ぶだけなので難しくないですね。

`abort()` メソッドを外から呼べるようにするために、今までのセクションにもでてきた<<xhr-promise.js,`getURL`>>を少し拡張して、
XHRを包んだpromiseオブジェクトと共にそのXHRを中止するメソッドを持つオブジェクトを返すようにしています。

[source,javascript]
[[delay-race-cancel.js]]
.delay-race-cancel.js
----
include::embed/embed-delay-race-cancel.js[]
----

これで必要な要素は揃ったので後は、Promiseを使った処理のフローに並べていくだけです。
大まかな流れとしては以下のようになります。

. `cancelableXHR` を使いXHRのpromiseオブジェクトと中止を呼び出すメソッドを取得する
. `timeoutPromise` を使いXHRのpromiseとタイムアウト用のpromiseを `Promise.race` で競争させる
* XHRが時間内に取得出来た場合
.. 通常のpromiseと同様に `then` で中身を取得する
* タイムアウトとなった場合は
.. `throw TimeoutError` されるので `catch` する
.. catchしたエラーオブジェクトが `TimeoutError` のものだったら `abort` を呼び出してXHRをキャンセルする

これらの要素を全てまとめると次のように書けます。

[role="executable"]
[source,javascript]
[[delay-race-cancel-play.js]]
.delay-race-cancel-play.js
----
include::embed/embed-delay-race-cancel-play.js[]
----

これで、一定時間後に解決されるpromiseオブジェクトを使ったタイムアウト処理が実現できました。

[NOTE]
通常の開発の場合は繰り返し使えるように、それぞれファイルに分割して定義しておくといいですね。

=== promise和操作方法

先ほどの<<delay-race-cancel.js,`cancelableXHR`>>はpromiseオブジェクトと操作のメソッドが
一緒になったオブジェクトを返すようにしていたため少し分かりにくかったかもしれません。

一つの関数は一つの値(promiseオブジェクト)を返すほうが見通しがいいと思いますが、
`cancelableXHR` の中で生成した `req` は外から参照できないので、特定のメソッド(先ほどのケースは `abort`)からは触れるようにする必要があります。

返すpromiseオブジェクト自体を拡張して `abort` 出来るようにするという手段もあると思いますが、
promiseオブジェクトは値を抽象化したオブジェクトであるため、何でも操作用のメソッドをつけていくと複雑になってしまうかもしれません。

一つの関数で全てやろうとしてるのがそもそも良くないので、
ひとつの関数で何でもやるのは止めて、以下のように関数に分離していくというのが妥当な気がします。

* XHRを行うpromiseオブジェクトを返す
* promiseオブジェクトを渡したら該当するXHRを止める

これらの処理をまとめたモジュールを作れば今後の拡張がしやすいですし、
一つの関数がやることも小さくて済むので見通しも良くなると思います。

モジュールの作り方は色々作法(AMD,CommonJS,ES6 module etc..)があるので
ここでは、先ほどの `cancelableXHR` をNode.jsのモジュールとして作りなおしてみます。

[source,javascript]
[[cancelableXHR.js]]
.cancelableXHR.js
----
include::lib/cancelableXHR.js[]
----

使い方もシンプルに `createXHRPromise` でXHRのpromiseオブジェクトを作成して、
そのXHRを `abort` したい場合は `abortPromise(promise)` にpromiseオブジェクトを渡すという感じで利用できるようになります。

[source,javascript]
----
var cancelableXHR = require("./cancelableXHR");

var xhrPromise = cancelableXHR.createXHRPromise('http://httpbin.org/get');// <1>
xhrPromise.catch(function (error) {
    // abort されたエラーが呼ばれる
});
cancelableXHR.abortPromise(xhrPromise);// <2>
----
<1> XHRをラップしたpromiseオブジェクトを作成
<2> 1で作成したpromiseオブジェクトのリクエストをキャンセル


=== 总结

ここでは以下の事について学びました。

* 一定時間後に解決されるdelayPromise
* delayPromiseとPromise.raceを使ったタイムアウトの実装
* XHRのpromiseのリクエストのキャンセル
* モジュール化によるpromiseオブジェクトと操作の分離

Promiseは処理のフローを制御する力に優れているため、
それを最大限活かすためには一つの関数でやり過ぎないで処理を小さく分けること等、
今までのJavaScriptで言われているような事をより意識していいのかもしれません。
